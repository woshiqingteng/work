# 段的概念_重定位的引入 #
## 1. 问题的引入

* `led.imx = 头部 + led.bin`  或 `led.stm32 = 头部 + led.bin`
  * 头部里含有位置信息(addr)：固件要把led.bin复制到哪里去
    * 链接程序时，指定了链接地址，一般来说头部信息的addr就等于链接地址
    * 如果，偏要修改头部信息的addr，让它不等于链接地址，会发生什么是？
  * 头部里含有长度信息(len)：led.bin多大
* 在串口程序中添加全局变量，把它打印出来，看看会发生什么事。

## 2. 段的概念

### 2.1 程序直接烧写在ROM上

 代码段、只读数据段、可读可写的数据段、BSS段。

```c
char g_Char = 'A';           // 可读可写，不能放在ROM上，应该放在RAM里
const char g_Char2 = 'B';    // 只读变量，可以放在ROM上
int g_A = 0;   // 初始值为0，干嘛浪费空间保存在ROM上？没必要
int g_B;       // 没有初始化，干嘛浪费空间保存在ROM上？没必要
```

所以，程序分为这几个段：

* 代码段(RO-CODE)：就是程序本身，不会被修改
* 可读可写的数据段(RW-DATA)：有初始值的全局变量、静态变量，需要从ROM上复制到内存
* 只读的数据段(RO-DATA)：可以放在ROM上，不需要复制到内存
* BSS段或ZI段：
  * 初始值为0的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以
  * 未初始化的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以
* 局部变量：保存在栈中，运行时生成
* 堆：一块空闲空间，使用malloc函数来管理它，malloc函数可以自己写

### 2.2 片内固件功能强大，理解段的概念麻烦一点

看视频

## 3. 重定位

保存在ROM上的全局变量的值，在使用前要复制到内存，这就是数据段重定位。

想把代码移动到其他位置，这就是代码重定位。