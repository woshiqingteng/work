# 重定位要做的事
## 1. 程序中含有什么？
* 代码段：如果它不在链接地址上，就需要重定位
* 只读数据段：如果它不在链接地址上，就需要重定位
* 可读可写的数据段：如果它不在链接地址上，就需要重定位
* BSS段：不需要重定位，因为程序里根本不保存BSS段，使用前把BSS段对应的空间清零即可

## 2. 谁来做重定位？

* 程序本身：它把自己复制到链接地址去
* 一开始，程序可能并不位于它的链接地址上，为什么它可以执行重定位的操作？
  * 因为重定位的代码是使用“位置无关码”写的
* 什么叫位置无关码：这段代码扔在任何位置都可以运行，跟它所在的位置无关
* 怎么写出位置无关码：
  * 跳转：使用相对跳转指令，不能使用绝对跳转指令
    * 只能使用branch指令(比如`bl main`)，不能给PC直接复制，比如`ldr pc, =main`
  * 不要访问全局变量、静态变量
  * 不使用字符串

## 3. 怎么做重定位和清除BSS段？

* 核心：复制
* 复制的三要素：源、目的、长度
  * 怎么知道代码段/数据段保存在哪？(加载地址)
  * 怎么知道代码段/数据段要被复制到哪？(链接地址)
  * 怎么知道代码段/数据段的长度？
* 怎么知道BSS段的地址范围：起始地址、长度？
* 这一切
  * 在keil中使用散列文件(Scatter File)来描述
  * 在GCC中使用链接脚本(Link Script)来描述

## 4. 加载地址和链接地址的区别

程序运行时，**应该**位于它的链接地址处，因为：

* 使用函数地址时用的是"函数的链接地址"，所以代码段**应该**位于链接地址处
* 去访问全局变量、静态变量时，用的是"变量的链接地址"，所以数据段**应该**位于链接地址处

但是： 程序一开始时可能并没有位于它的"链接地址"：

* 比如对于STM32F103，程序被烧录器烧写在Flash上，这个地址称为"加载地址"
* 比如对于IMX6ULL/STM32MP157，片内ROM根据头部信息把程序读入内存，这个地址称为“加载地址”

当**加载地址 ！= 链接地址**时，就需要重定位。