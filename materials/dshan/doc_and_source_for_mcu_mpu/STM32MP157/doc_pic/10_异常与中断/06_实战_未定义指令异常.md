# 实战_未定义指令异常

要想深入理解异常处理，需要写程序来验证。
本节课程故意执行一条未定义的指令，让它触发异常。

参考资料：`ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf`

## 1.1 A7的异常向量表

从向量表可以看出，A7支持哪些异常：未定义指令、软中断(SVC)、预取指令中止、数据中止、IRQ、FIQ。

```
_start: 
    b	reset
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
```



## 1.2 什么是未定义指令？

未定义指令，即使"还没有定义的指令"，也就是CPU不认识的指令。
很多时候，我们故意在代码里插入一些伪造的指令，故意让CPU执行到它时触发错误。
这在调试时很有用，比如想打断点：怎么实现呢？
有很多种方法：硬件监视点(watch point，数量有限)、软件断点(数量无限)。
软件断点就是使用`未定义指令`来实现的，比如想让程序执行到某个地址A时停下来，可以这样做：

* 地址A上原来的指令是`xxx`
* 我们故意把它改成`yyy`，改成一条CPU无法识别的指令
* 当CPU执行到地址A上的`yyy`指令时，触发异常
* 在异常处理函数里，打印更多调试信息
* 调试完毕后，恢复地址A上的指令为`xxx`
* 从地址A重新执行程序

本节教程并不打算制作调试器，这里只是讲述一下未定义指令的作用，使用它来深入理解异常处理流程。



## 1.3 在汇编代码里插入未定义指令

在代码中插入：

```
.word  0xffffffff
```

看看会发生什么事情。

 

### 1.4 编程

### 1.4.1 设置异常向量表基地址

```
MRC p15, 0, <Rt>, c12, c0, 0 ; Read VBAR into Rt
MCR p15, 0, <Rt>, c12, c0, 0 ; Write Rt to VBAR
```



### 1.4.2 设置未定义模式的栈

### 1.4.3 保存现场



### 1.4.4 处理异常



### 1.4.5 恢复现场