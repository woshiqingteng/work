# 数据段重定位

参考手册：[Using LD, the GNU linker](http://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html)

## 1. 怎么获得各个段的信息

数据复制3要素：源、目的、长度。
怎么知道某个段的加载地址、链接地址、长度？

### 1.1 怎么确定源？

可以用ADR伪指令获得当前代码的地址，对于这样的代码：

```
.text
.global  _start
_start: 
    ......
    adr r0, _start
```

adr是伪指令，它最终要转换为真实的指令。它怎么获得`_start`代码的当前所处地址呢？
实际上，`adr r0, _start`指令的本质是`r0 = pc - offset`，offset是在链接时就确定了。

### 1.2 怎么确定目的地址？

也就是怎么确定链接地址？可以用LDR伪指令。
对于这样的代码：

```
.text
.global  _start
_start: 
    ......
    ldr r0, =_start
```

ldr是伪指令，它最终要转换为真实的指令。它怎么获得`_start`的链接地址呢？
_start的链接地址在链接时，由链接脚本确定。



### 1.3 如何获得更详细的信息

在链接脚本里可以定义各类符号，在代码里读取这些符号的值。
比如对于下面的链接脚本，可以使用`__bss_start`、`__bss_end`得到BSS段的起始、结束地址：

```
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
```

上述代码里，有一个"."，它被称为"Location Counter"，表示当前地址：可读可写。
它表示的是链接地址。

```
. = 0xABC;       /* 设置当前地址为0xABC */ 
_abc_addr = . ;  /* 设置_abc_addr等于当前地址 */
. = . + 0x100;   /* 当前地址增加0x100 */
. = ALIGN(4);    /* 当前地址向4对齐 */
```

注意："Location Counter"只能增大，不能较小。

## 2. 编写程序重定位数据段

### 2.1 修改链接脚本

我们故意只重定位数据段，在后面的课程再来重定位代码段并引入更多知识。
数据段要被复制到哪去？需要在链接脚本里确定一下：增加了`__data_start`

```
SECTIONS {
    . = 0xC0200000;   /* 对于STM32MP157设置链接地址为0xC0200000, 对于IMX6ULL设为0x80200000 */

    . = ALIGN(4);
    .text      :
    {
      *(.text)
    }

    . = ALIGN(4);
    __rodata_start = .;
    .rodata : { *(.rodata) }

    . = ALIGN(4);
    .data : { *(.data) }

    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
}
```

### 2.2 编写程序

修改start.S：

```
ldr r0, =__data_start   /* 目的: 链接地址 */

/* 计算data段的当前地址:
 * _start的链接地址 - _start的当前地址 = __rodata_start的链接地址 - rodata段的当前地址
 * data段的当前地址 = __rodata_start的链接地址 - (_start的链接地址 - _start的当前地址)
 */
ldr r0, =__rodata_start

ldr r2, =_start  /* link addr */
adr r3, _start   /* load addr */
sub r2, r2, r3
sub r1, r0, r2   /* 源 */

ldr r3, =__bss_start
sub r2, r3, r0

bl memcpy    /* r0: 目的, r1: 源, r2：长度 */

```