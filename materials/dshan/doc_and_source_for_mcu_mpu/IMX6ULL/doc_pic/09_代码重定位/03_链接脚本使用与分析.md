# 链接脚本使用与分析

参考手册：[Using LD, the GNU linker](http://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html)

## 1. 重定位的实质: 移动数据

把代码段、只读数据段、数据段，移动到它的链接地址处。
也就是**复制**！
数据复制的三要素：源、目的、长度。

* 数据保存在哪里？加载地址

* 数据要复制到哪里？链接地址

* 长度

这3要素怎么得到？
在GCC中，使用链接脚本来描述。
在keil中，跟链接脚本对应的是散列文件，散列的意思就是"分散排列"，在STM32F103这类资源紧缺的单片机芯片中：

* 代码段保存在Flash上，直接在Flash上运行(当然也可以重定位到内存里)
* 数据段保存在Flash上，使用前被复制到内存里

但是，在资源丰富的MPU板子上：

* 内存很大，几十M、几百M，甚至几G
* 可能没有XIP设备(XIP: eXecute In Place，原地执行)
  * 没有类似STM32F103上的Flash，代码无法在存储芯片上直接运行

* 基于这些特点，在MPU板子上
  * 代码段、数据段、BSS段等等，运行时没有必要分开存放
  * 重定位时，把整个程序(包括代码段、数据段等)，一起复制到它的链接地址去

## 2. 链接脚本示例

### 2.1 链接脚本示例

```
SECTIONS {
    . = 0xC0200000;   /* 对于STM32MP157设置链接地址为0xC0200000, 对于IMX6ULL设为0x80200000 */

    . = ALIGN(4);
    .text      :
    {
      *(.text)
    }

    . = ALIGN(4);
    .rodata : { *(.rodata) }

    . = ALIGN(4);
    .data : { *(.data) }

    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
}
```

### 2.2 链接脚本语法

#### 2.2.1 完整的语法

一个链接脚本由一个SECTIONS组成。
一个SECTIONS里面，含有一个或多个section。

```
SECTIONS {
...
secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } >region :phdr =fill
...
}
```

section是链接脚本的核心，它的语法如下：

```
secname start BLOCK(align) (NOLOAD) : AT ( ldadr )
  { contents } >region :phdr =fill
```

#### 2.2.2 几个例子

实际上不需要那么复制，不需要把语法里各项都写完。

* 示例1

```
SECTIONS { 
  .text : { *(.text) }            /* secname为".text"，里面是所有文件的".text"段 */ 
  .data : { *(.data) }            /* secname为".data"，里面是所有文件的".data"段 */
  .bss :  { *(.bss)  *(.COMMON) } /* secname为".bss"，里面是所有文件的".bss"段和".COMMON"段 */
} 
```

* 示例2
  还可以按文件指定
```
SECTIONS {
  outputa 0x10000 :     /* secname为"outputa"，链接地址为0x10000 */ 
    {
    first.o                 /* 把first.o整个文件放在前面 */
    second.o (.text)        /* 接下来是second.o的".text"段 */
    }
  outputb :             /* secname为"outputb"，链接地址紧随outputa */ 
    {
    second.o (.data)        /* second.o的".data"段 */
    }
  outputc :             /* secname为"outputc"，链接地址紧随outputb */  
    {
    *(.bss)                 /* 所有文件的".bss"段 */
    *(.COMMON)              /* 所有文件的".COMMON"段 */
    }
}
```

* 示例3

```
SECTIONS { 
  .text 0x10000 : AT (0)       /* secname为".text"，链接地址是0x10000，加载地址是0 */ 
  { *(.text) }  
  .data 0x20000 : AT (0x1000)  /* secname为".data"，链接地址是0x20000，加载地址是0x1000 */
  { *(.data) } 
  .bss :                       /* secname为".bss"，链接地址紧随.data段，加载地址紧随.data段 */
  { *(.bss)  *(.COMMON) } 
} 
```



## 3. 怎么获得各个段的信息

数据复制3要素：源、目的、长度。
怎么知道某个段的加载地址、链接地址、长度？

### 3.1 怎么确定源？

可以用ADR伪指令获得当前代码的地址，对于这样的代码：

```
.text
.global  _start
_start: 
    ......
    adr r0, _start
```

adr是伪指令，它最终要转换为真实的指令。它怎么获得`_start`代码的当前所处地址呢？
实际上，`adr r0, _start`指令的本质是`r0 = pc - offset`，offset是在链接时就确定了。

### 3.2 怎么确定目的地址？

也就是怎么确定链接地址？可以用LDR伪指令。
对于这样的代码：

```
.text
.global  _start
_start: 
    ......
    ldr r0, =_start
```

ldr是伪指令，它最终要转换为真实的指令。它怎么获得`_start`的链接地址呢？
_start的链接地址在链接时，由链接脚本确定。



### 3.3 如何获得更详细的信息

在链接脚本里可以定义各类符号，在代码里读取这些符号的值。
比如对于下面的链接脚本，可以使用`__bss_start`、`__bss_end`得到BSS段的起始、结束地址：

```
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
```

上述代码里，有一个"."，它被称为"Location Counter"，表示当前地址：可读可写。
它表示的是链接地址。

```
. = 0xABC;       /* 设置当前地址为0xABC */ 
_abc_addr = . ;  /* 设置_abc_addr等于当前地址 */
. = . + 0x100;   /* 当前地址增加0x100 */
. = ALIGN(4);    /* 当前地址向4对齐 */
```

注意："Location Counter"只能增大，不能较小。

## 4. 编写程序重定位数据段

### 4.1 修改链接脚本

我们故意只重定位数据段，在后面的课程再来重定位代码段并引入更多知识。
数据段要被复制到哪去？需要在链接脚本里确定一下：增加了`__data_start`

```
SECTIONS {
    . = 0xC0200000;   /* 对于STM32MP157设置链接地址为0xC0200000, 对于IMX6ULL设为0x80200000 */

    . = ALIGN(4);
    .text      :
    {
      *(.text)
    }

    . = ALIGN(4);
    __data_start = .;
    .rodata : { *(.rodata) }

    . = ALIGN(4);
    .data : { *(.data) }

    . = ALIGN(4);
    __bss_start = .;
    .bss : { *(.bss) *(.COMMON) }
    __bss_end = .;
}
```

### 4.2 编写程序

修改start.S：

```
ldr r0, =__data_start   /* 目的: 链接地址 */

/* 计算data段的当前地址:
 * _start的链接地址 - _start的当前地址 = __data_start的链接地址 - data段的当前地址
 * data段的当前地址 = __data_start的链接地址 - (_start的链接地址 - _start的当前地址)
 */
adr r1, _start
ldr r2, =_start
sub r2, r2, r1
sub r1, r0, r2

/* 计算data段的长度 */
ldr r2, =__bss_start
ldr r3, =__data_start
sub r2, r2, r3

bl memcpy    /* 需要3个参数: dest, src, len */
```