# 纯汇编点灯 #

## 1. 程序流程图

```flow
st=>start: start
gpio_on=>operation: 使能GPIO模块
gpio_mode=>operation: 设置引脚为GPIO功能
gpio_out=>operation: 设置引脚为输出
gpio_high=>operation: 设置引脚输出高电平
gpio_low=>operation: 设置引脚输出低电平
delay_func1=>subroutine: delay
delay_func2=>subroutine: delay
e=>end: end
st->gpio_on->gpio_mode->gpio_out->gpio_high
gpio_high->delay_func1->gpio_low->delay_func2(left)->gpio_high
```
## 2. delay函数流程图

```flow
st=>start: start
sub=>operation: R0减1
cmp_zero=>condition: 等于0?
return=>operation: 返回LR所示地址

st->sub->cmp_zero
cmp_zero(no)->sub
cmp_zero(yes)->return
```

## 3. 写程序
* 寄存器操作
  对于寄存器的操作，主要涉及读、修改、写。

  * 读可以使用LDR指令，代码为`LDR R1, [R0]`

  * 写使用STR指令，代码为`STR R1, [R0]`

  * 修改稍微复杂，清除位使用BIC或AND指令，设置位使用ORR指令

    ```
    LDR R0, =(1<<20) | (1<<21)
    BIC R1, R1, R0              ; 清除R1的bit20, bit21
    LDR R0, =(1<<20)
    ORR R1, R1, R0              ; 设置R1的bit20
    ```

    

* 函数里的条件判断
比如减1操作，代码为`SUB R0, R0, #1`
但是顺便使用减1后的结果影响程序状态寄存器，代码为`SUBS R0, R0, #1`

* 程序的调用与返回
  * 传参，代码为`LDR R0, =VAL`
  + 调用，代码为`BL delay`，它顺便把下一条指令的地址保存在LR寄存器了
  + 返回，代码为`MOV PC, LR`

## 4. 现场写程序