# 异常处理深入分析_保存现场

## 1.1 回顾一下处理流程

CPU每执行完一条指令都会检查有无中断/异常产生，发现有中断/异常产生，开始处理：

* 保存现场
* 分辨异常/中断，调用对应的异常/中断处理函数
* 恢复现场

对于不用的处理器，具体的处理工作有差别：

* 保存现场：cortex M3/M4里是硬件完成，cortex A7等是软件实现
* 分辨异常/中断：cortex M3/M4里是硬件完成，cortex A7等是软件实现
* 调用处理函数：cortex M3/M4里是硬件来调用，cortex A7等是软件自己去调用
* 恢复现场：cortex M3/M4里是软件触发、硬件实现，cortex A7等是软件实现

不管是硬件还是软件实现，第一步都是**保存现场**。



## 1.2 为什么要保存现场

![](lesson\exception_irq\008_save_register.png)

任何程序，最终都会转换为机器码，上述C代码可以转换为右边的汇编指令。
对于这4条指令，它们可能随时被异常打断，怎么保证异常处理完后，被打断的程序还能正确运行？

* 这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变
* 执行完第3条指令时，比较结果保存在**程序状态寄存器**里，程序被打断时、恢复运行时，程序状态寄存器保持不变

* 这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变

内存保持不变，这很容易实现，程序不越界就可以。
所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：

* 在处理异常前，把这些寄存器保存在栈中，这称为**保存现场**
* 在处理完异常后，从栈中恢复这些寄存器，这称为**恢复现场**



## 1.3 保存现场

ARM处理器中有这些寄存器：
![](lesson\exception_irq\003_cpu_register.png)

在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。
约定R0-R15寄存器的用途：

* R0-R3

  调用者和被调用者之间传参数

* R4-R11

  函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。

![](lesson\exception_irq\004_atpcs.png)

还有一个**程序状态寄存器**，对于M3/M4它被称为**XPSR**，对于A7它被称为**CPSR**，我们简称为PSR。
R0-R15、PSR，就是所谓的**现场**。
发生异常/中断后，在处理异常/中断前，需要**保存现场**，难道需要保存所有这些寄存器吗？
不需要！
在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。
这些寄存器被拆分成2部分：**调用者保存的寄存器(R0-R3,R12,LR,PSR)**、**被调用者保存的寄存器(R4-R11)**。
比如函数A调用函数B，函数A应该知道：

* R0-R3是用来传参数给函数B的
* 函数B可以肆意修改R0-R3
* 函数A不要指望函数B帮你保存R0-R3
* 保存R0-R3，是函数A的事情
* 对于LR、PSR也是同样的道理，保存它们是函数A的责任

对于函数B：

* 我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复
* 保证在B函数调用前后，函数A看到的R4-R11保存不变

假设函数B就是异常/中断处理函数，函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：

* 调用者保存的寄存器(R0-R3,R12,LR,PSR)
* PC



## 1.4 对于M3/M4

参考资料：`DDI0403E_B_armv7m_arm.pdf`、`ARM Cortex-M3与Cortex-M4权威指南.pdf`、`PM0056.pdf`

### 1.4.1 硬件保存现场

![](lesson\exception_irq\005_saved_register_for_exception.png)

### 1.4.2 然后调用C函数

C函数执行完后，它返回LR所指示的位置。
难道把LR设置为被中断的程序的地址就行了吗？
如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？
M3/M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为**EXC_RETURN**。
当PC寄存器的值等于**EXC_RETURN**时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。
**EXC_RETURN**的值，请参考`ARM Cortex-M3与Cortex-M4权威指南.pdf`，截图如下：
![](lesson\exception_irq\006_exc_return.png)



补充2个知识点：

* 操作模式：M3/M4有两个操作模式

  * 处理模式：执行中断服务程序等异常处理时，处于**处理模式**
  * 线程模式：执行普通应用程序代码时，处于**线程模式**

* M3/M4有连个SP寄存器：SP_process、SP_main
  * 有些RTOS在运行用户程序时会使用SP_process，默认使用SP_main。



## 1.5 对于A7

它寄存器如下：
![](lesson\exception_irq\007_bank_register.png)

处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。
上图中深色的寄存器，表示该模式下的"Banked"寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。
比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。

比较值得关注的是FIQ模式，名为"快中断"，它有很多"Banked"寄存器：R8-R12,SP,LR。
在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的"R8-R12,SP,LR"了。
省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为"FIQ"。

从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。



当发生异常时，以IRQ为例：

* CPU会自动切换进入对应的模式，比如进入IRQ模式
* 并且会把被中断是的CPSR保存到SPSR_irq里

所以发生异常/中断时，在保存现场时，只需要保存：

* 调用者保存的寄存器(R0-R3,R12,LR)
* PC