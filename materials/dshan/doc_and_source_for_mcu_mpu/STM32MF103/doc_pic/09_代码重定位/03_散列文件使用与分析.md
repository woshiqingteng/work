# 散列文件使用与分析

## 1. 重定位的实质: 移动数据
把代码段、只读数据段、数据段，移动到它的链接地址处。
也就是**复制**！
数据复制的三要素：源、目的、长度。

* 数据保存在哪里？加载地址

* 数据要复制到哪里？链接地址

* 长度

这3要素怎么得到？
在keil中，使用散列文件来描述。
散列？分散排列？
是的，在STM32F103这类资源紧缺的单片机芯片中，

* 代码段保存在Flash上，直接在Flash上运行(当然也可以重定位到内存里)
* 数据段保存在Flash上，使用前被复制到内存里

## 2. 散列文件示例

### 2.1 示例代码

```
; *************************************************************
; *** Scatter-Loading Description File generated by uVision ***
; *************************************************************

LR_IROM1 0x08000000 0x00080000  {    ; load region size_region
  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address
   *.o (RESET, +First)
   .ANY (+RO)
   .ANY (+XO)
  }
  RW_IRAM1 0x20000000 0x00010000  {  ; RW data
   .ANY (+RW +ZI)
  }
}
```

### 2.2 散列文件语法

一个散列文件由一个或多个`Load region`组成：

```
load_region_description ::=
load_region_name (base_address | ("+" offset)) [attribute_list] [max_size]
"{"
execution_region_description+
"}
```

`Load region`中含有一个或多个`Execution region`，
`Execution region`语法如下：

```
execution_region_description ::=
exec_region_name (base_address | "+" offset) [attribute_list] [max_size | length]
"{"
input_section_description*
"}
```

`Execution region`中含有一个或多个`Input section`，
`Input section`语法如下：

```
input_section_description ::=
module_select_pattern [ "(" input_section_selector ( ","
input_section_selector )* ")" ]
input_section_selector ::=
"+" input_section_attr |
input_section_pattern |
input_section_type |
input_symbol_pattern |
section_properties
```



## 3. 散列文件解析

![](lesson\relocate\001_sct_example.png)

\*.o ：所有objects文件

\*：所有objects文件和库，在一个散列文件中只能使用一个\*

.ANY：等同于\*，优先级比\*低；在一个散列文件的多个可执行域中可以有多个`.ANY`



## 4. 怎么获得region的信息

### 4.1 可执行域的信息

![](lesson\relocate\002_execution_region_symbol.png)

### 4.2 加载域的信息

![](lesson\relocate\003_load_region_symbol.png)

### 4.3 汇编代码里怎么使用这些信息

示例代码如下：

```
IMPORT |Image$$RW_IRAM1$$Base|
IMPORT |Image$$RW_IRAM1$$Length|
IMPORT |Load$$RW_IRAM1$$Base|

LDR R0, = |Image$$RW_IRAM1$$Base|    ; DEST
LDR R1, = |Load$$RW_IRAM1$$Base|     ; SORUCE
LDR R2, = |Image$$RW_IRAM1$$Length|  ; LENGTH
```

### 4.4 C语言里怎么使用这些信息

#### 4.4.1 方法1

声明为外部变量。
注意：使用时**需要**使用取址符：

```
extern int Image$$RW_IRAM1$$Base;
extern int Load$$RW_IRAM1$$Base;
extern int Image$$RW_IRAM1$$Length;

memcpy(&Image$$RW_IRAM1$$Base, &Image$$RW_IRAM1$$Length, &Load$$RW_IRAM1$$Base);
```

#### 4.4.2 方法2

声明为外部数组。
注意：使用时**不需要**使用取址符：

```
extern char Image$$RW_IRAM1$$Base[];
extern char Load$$RW_IRAM1$$Base[];
extern int Image$$RW_IRAM1$$Length;

memcpy(Image$$RW_IRAM1$$Base, Image$$RW_IRAM1$$Length, &Load$$RW_IRAM1$$Base);
```