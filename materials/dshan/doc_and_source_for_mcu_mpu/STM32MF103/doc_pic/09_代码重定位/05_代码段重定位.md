# 代码段重定位

## 1. 加载地址等于链接地址
在默认散列文件中，代码段的`load address = execution address`，
也就是加载地址和执行地址(链接地址)一致，所以无需重定位：

```
LR_IROM1 0x08000000 0x00080000  {    ; load region size_region
  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$$Sections)
   .ANY (+RO)
   .ANY (+XO)
  }
  RW_IRAM1 0x20000000 0x00010000  {  ; RW data
   .ANY (+RW +ZI)
  }
}
```

##   2.加载地址不等于链接地址

有时候，我们需要把程序复制到内存里运行，比如：

* 想让程序执行得更快：需要把代码段复制到内存里
* 程序很大，保存在片外SPI Flash中，SPI Flash上的代码无法直接执行，需要复制到内存里

这时候，需要修改散列文件，把代码段的可执行域放在内存里。
那么程序运行时，需要尽快把代码段重定位到内存。
散列文件示例：

```
LR_IROM1 0x08000000 0x00080000  {    ; load region size_region
  ER_IROM1 0x20000000   {  ; load address != execution address
   *.o (RESET, +First)
   .ANY (+RO)
   .ANY (+XO)
  }
  RW_IRAM1 +0   {  ; RW data
   .ANY (+RW +ZI)
  }
}
```

上面的散列文件中：

* 可执行域ER_IROM1
  * 加载地址为0x08000000，可执行地址为0x20000000，两者不相等
  * 板子上电后，从0x08000000处开始运行，需要尽快把代码段复制到0x20000000
* 可执行域RW_IRAM1
  * 加载地址：紧跟着ER_IROM1的加载地址
  * 可执行地址：紧跟着ER_IROM1的可执行地址
  * 需要尽快把数据段复制到可执行地址处

数据段的重定位我们做过实验，
如果代码段不重定位的话，会发生什么事？



## 3. 代码段不重定位的后果

不能使用链接地址来调用函数

* 汇编中

  ```
  ldr  pc, =main   ; 这样调用函数时，用到main函数的链接地址，如果代码段没有重定位，则跳转失败
  ```


* C语言中

  ```c
  void (*funcptr)(const char *s, unsigned int val);
  funcptr = put_s_hex;
  funcptr("hello, test function ptr", 123);
  ```



## 4. 代码段重定位

### 4.1 代码段在哪？多大？

在散列文件中，代码段在可执行域`ER_IROM1`中描述：

```
LR_IROM1 0x08000000 0x00080000  {    ; load region size_region
  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address
   *.o (RESET, +First)
   *(InRoot$$Sections)
   .ANY (+RO)
   .ANY (+XO)
  }
  RW_IRAM1 0x20000000 0x00010000  {  ; RW data
   .ANY (+RW +ZI)
  }
}
```

代码段的链接地址(基地址)、长度，使用下面的符号获得：

![](lesson\relocate\005_text_section_execution_symbol.png)

代码段的加载地址，使用下面的符号获得：

![](lesson\relocate\006_text_section_load_symbol.png)



### 4.2 怎么重定位

#### 4.2.1 汇编代码

```
IMPORT |Image$$ER_IROM1$$Base|
IMPORT |Image$$ER_IROM1$$Length|
IMPORT |Load$$ER_IROM1$$Base|

LDR R0, = |Image$$ER_IROM1$$Base|    ; DEST
LDR R1, = |Load$$ER_IROM1$$Base|     ; SORUCE
LDR R2, = |Image$$ER_IROM1$$Length|  ; LENGTH
BL memcpy
```

#### 4.2.2 C语言代码

* 方法1

声明为外部变量，使用时**需要**使用取址符：

```
extern int Image$$ER_IROM1$$Base;
extern int Load$$ER_IROM1$$Base;
extern int Image$$ER_IROM1$$Length;

memcpy(&Image$$ER_IROM1$$Base, &Image$$ER_IROM1$$Length, &Load$$ER_IROM1$$Base);
```

* 方法2

声明为外部数组，使用时**不需要**使用取址符：

```
extern char Image$$ER_IROM1$$Base[];
extern char Load$$ER_IROM1$$Base[];
extern int Image$$ER_IROM1$$Length;

memcpy(Image$$ER_IROM1$$Base, Image$$ER_IROM1$$Length, &Load$$ER_IROM1$$Base);
```



## 5. 为什么重定位之前的代码也可以正常运行？

因为重定位之前的代码是使用**位置无关码**写的：

* 只使用相对跳转指令：B、BL

* 不只用绝对跳转指令：

  ```
  LDR R0, =main
  BLX R0
  ```

* 不访问全局变量、静态变量、字符串、数组

* 重定位完后，使用绝对跳转指令跳转到XXX函数的链接地址去

  ```
  BL main         ; bl相对跳转，程序仍在Flash上运行
  
  LDR R0, =main   ; 绝对跳转，跳到链接地址去，就是跳去内存里执行
  BLX R0
  ```

  