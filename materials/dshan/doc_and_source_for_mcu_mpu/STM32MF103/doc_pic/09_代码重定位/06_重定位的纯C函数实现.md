# 重定位的纯C函数实现

## 1. 难点
难点在于，怎么得到各个域的加载地址、链接地址、长度。

* 方法1

声明为外部变量，使用时**需要**使用取址符：

```
extern int Image$$ER_IROM1$$Base;
extern int Load$$ER_IROM1$$Base;
extern int Image$$ER_IROM1$$Length;

memcpy(&Image$$ER_IROM1$$Base, &Image$$ER_IROM1$$Length, &Load$$ER_IROM1$$Base);
```

* 方法2

声明为外部数组，使用时**不需要**使用取址符：

```
extern char Image$$ER_IROM1$$Base[];
extern char Load$$ER_IROM1$$Base[];
extern int Image$$ER_IROM1$$Length;

memcpy(Image$$ER_IROM1$$Base, Image$$ER_IROM1$$Length, &Load$$ER_IROM1$$Base);
```



## 2. 怎么理解上述代码

 对于这样的C变量：

```c
int g_a;
```

编译的时候会有一个符号表(symbol table)，如下：

| Name | Address  |
| ---- | -------- |
| g_a  | xxxxxxxx |

对于散列文件中的各类Symbol，有2中声明方式：

```c
extern int Image$$ER_IROM1$$Base;     // 声明为一般变量
extern char Image$$ER_IROM1$$Base[];  // 声明为数组
```

不管是哪种方式，它们都会保存在符号表里，比如：

| Name                  | Address  |
| --------------------- | -------- |
| g_a                   | xxxxxxxx |
| Image$$ER_IROM1$$Base | yyyyyyyy |

* 对于`int g_a`变量
  * 使用`&g_a`得到符号表里的地址。
* 对于`extern int Image$$ER_IROM1$$Base`变量
  * 要得到符号表中的地址，也是使用`&Image$$ER_IROM1$$Base`。
* 对于`extern char Image$$ER_IROM1$$Base[]`变量
  * 要得到符号表中的地址，直接使用`Image$$ER_IROM1$$Base`，不需要加`&`
  * 为什么？mage$$ER_IROM1$$Base本身就表示地址啊


